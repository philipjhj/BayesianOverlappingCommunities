classdef GibbsSamplerC
    properties
        %%  Input
        A % Data Matrix
        Atrue
        T=0; % Total # of samples
        Tstart=0; % Changes if error occurs to resume sampling
        pms % Hyperparameters (current)
        pmsTrue % if generated
        d % Number of communities
        dTrue
        k % k-flip parameter
        zTrue % Generated Z matrix (if available)
        qTrue % Generated Q matrix (if available)
        zTrueSorted
        qTrueSorted
        zTrueItemsPerm
        zTrueComponentPerm
        qTrueItemsPerm
        qTrueComponentPerm
        zLabels
        qLabels
        MissingData % Indices of missing data
        % Link probabilities
        pa
        pb
        Bds
        Rds
        
        %% Settings
        Debug = false;
        ActiveGibbs = true;
        Constrained = true;
        activeHyper = true;
        hyperindex = [];
        verbose = true;
        StartWithZQTrue = false;
        
        %% Output
        zSamples % Samples generated by gibbs
        qSamples % Samples generated by gibbs
        zMAP
        qMAP
        zMAPIDX
        qMAPIDX
        zMAPSorted
        qMAPSorted
        zMAPItemsPerm
        zMAPComponentPerm
        qMAPItemsPerm
        qMAPComponentPerm
        logpMAP
        logpIDX % index in chain of log-p MAP
        linkProbs
        pmsSamples % Samples generated by gibbs
        logPs % Log probability of samples
        SuffStatAll % SuffStats
        cpuTime
        wallTime
        PostPredDistMat % Posterior Predictive Distribution
        AUC
    end
    
    methods
        % CONSTRUCTOR ************
        function obj = GibbsSamplerC(A,d,k,pms,Z,Q)
            if nargin == 1; % default values
                
                % input arg A is seed for RNG
                
                obs = 1000; % No. of observations
                feas = 2000; % No. of features
                obj.dTrue = 20; % No. of concepts
                obj.k = 3; % No. used in k-flip
                
                bs = [1 1];
                rs = [1 1];
                
                pas = [1 1]; % pa_plus, pa_minus
                pbs = [1 1]; % pb_plus, pb_minus
                rng(A)
                [obj.A,obj.zTrue,obj.qTrue,obj.pa,obj.pb,obj.Bds,obj.Rds] = ...
                    obj.GenerateDataFromModel(obs,feas,obj.dTrue,bs,rs,pas,pbs);
                obj.pmsTrue = [bs; rs; pas; pbs;];%Parameters
                obj.d = obj.dTrue;%12;
                obj.pms = [1 1; 1 1; 1 1; 1 1];
            else
                obj.A = A;
                obj.d = d;
                obj.k = k;
                if nargin < 4
                    % default pms if no other given
                    obj.pms = [1 1; 1 1; 1 1; 1 1];
                else
                    obj.pms = pms;
                    if nargin > 5
                        % if know Z and Q exists (synthetic data)
                        obj.zTrue = Z;
                        obj.qTrue = Q;
                    end
                end
            end
            if ~isempty(obj.zTrue)
                [obj.zTrueSorted,obj.zTrueItemsPerm,...
                    obj.zTrueComponentPerm] = sort_matrix(obj.zTrue,1);
                [obj.qTrueSorted,obj.qTrueItemsPerm,...
                    obj.qTrueComponentPerm] = sort_matrix(obj.qTrue,1);
            end
            obj.PostPredDistMat = zeros(size(obj.A));
            obj.Atrue = obj.A;
           % rng('shuffle')
        end
        
        % CLASS FUNCTIONS (EXTERNAL/CLASSFOLDER) ************
        
        % Sampler (See class folder for functions)
        obj = Sampler(obj,nSamples)
        
        % LogJoint her
        [max_prob, sample_max_Z, sample_max_Q,i,idx2] = findMAP(obj)
        CompareTrueSampleZQ(obj,MAP,mymode)
        
        obj = PosteriorPredictive(obj)
        
        
        % COMPUTATIONS ************
        function obj = LeaveOneOut(obj,nSamples)
            % Default values
            if nargin < 2
                nSamples = 200;
            end
            
            obj.PostPredDistMat = zeros(size(obj.PostPredDistMat));
            
            %if obj.verbose
            display('Computing Leave-One-Out Posterior Predictive Distribution');
            %end
            for i = 1:size(obj.A,1);
                for j = 1:size(obj.A,2);
                    %if obj.verbose
                    display([i j]);
                    %end
                    tempobj=obj.createMissingdata([i j]);
                    tempobj=tempobj.Sampler(nSamples);
                    tempobj=tempobj.PosteriorPredictive;
                    obj.PostPredDistMat = obj.PostPredDistMat+tempobj.PostPredDistMat;
                end
            end
        end
        
        
        function obj = computeZQMAP(obj)
            [obj.logpMAP,obj.zMAPIDX,obj.qMAPIDX,~,obj.logpIDX] = obj.findMAP;
            obj.zMAP = obj.zSamples{obj.zMAPIDX};
            obj.qMAP = obj.qSamples{obj.qMAPIDX};
            [obj.zMAPSorted, obj.zMAPItemsPerm,obj.zMAPComponentPerm] = ...
                sort_matrix(obj.zMAP,1);
            [obj.qMAPSorted, obj.qMAPItemsPerm,obj.qMAPComponentPerm] = ...
                sort_matrix(obj.qMAP,1);
        end
        
        function obj = computeLinkProbabilities(obj)
            nFeas = size(obj.A,2);
            obj.linkProbs = zeros(2,nFeas);
            for j = 1:nFeas;
                ninp = obj.SuffStatAll{obj.logpIDX}.NPaps(j)+obj.pmsSamples{obj.logpIDX}(3,1);
                ninm = obj.SuffStatAll{obj.logpIDX}.NPams(j)+obj.pmsSamples{obj.logpIDX}(3,2);
                noutp = obj.SuffStatAll{obj.logpIDX}.NPbps(j)+obj.pmsSamples{obj.logpIDX}(4,1);
                noutm = obj.SuffStatAll{obj.logpIDX}.NPbms(j)+obj.pmsSamples{obj.logpIDX}(4,2);
                
                a=(sum(betaintegral_noverbose(ninp+1,ninm,noutp,noutm)));
                b=(sum(betaintegral_noverbose(ninp,ninm,noutp+1,noutm)));
                c=(sum(betaintegral_noverbose(ninp,ninm,noutp,noutm)));
                %
                obj.linkProbs(1,j) = exp(a-c);
                obj.linkProbs(2,j) = exp(b-c);
            end
        end
        
        
        % UPDATES ************
        % Extending data structures to accomendate new samples
        function obj = updateT(obj,nSamples)
            obj.Tstart = obj.T+1;
            obj.T = obj.T+nSamples;
            %             if oldT<newT
            % Setting index for first sample
            %                 obj.T = newT;
            obj.logPs = [obj.logPs nan(3,nSamples)];
            obj.pmsSamples{obj.T} = [];
            obj.SuffStatAll{obj.T} = [];
            obj.zSamples{obj.T} = [];
            obj.qSamples{obj.T} = [];
            obj.cpuTime(obj.T) = 0;
            obj.wallTime(obj.T) = 0;
        end
        % Create missing data
        function obj = createMissingdata(obj,param)
            if nargin == 1; % default 10%
                Percent = 0.1;
                obj.A(randperm(numel(obj.A),round(numel(obj.A)*Percent))) = NaN;
                obj.MissingData = find(isnan(obj.A));
            elseif numel(param)==1 % percent
                obj.A(randperm(numel(obj.A),round(numel(obj.A)*param))) = NaN;
                obj.MissingData = find(isnan(obj.A));
            elseif numel(param)==2 % index
                obj.A(param(1),param(2)) = nan;
                obj.MissingData = sub2ind(size(obj.A),param(1),param(2));
            end
        end
        % Compute necessary values
        function obj = updateZQsort(obj)
            if ~isempty(obj.zTrue) && isempty(obj.zTrueSorted)
                [obj.zTrueSorted,obj.zTrueItemsPerm,...
                    obj.zTrueComponentPerm] = sort_matrix(obj.zTrue,1);
                [obj.qTrueSorted,obj.qTrueItemsPerm,...
                    obj.qTrueComponentPerm] = sort_matrix(obj.qTrue,1);
            end
        end
        
        % RESULTS ************
        function plotPostPred(obj)
            %figure
            %obj.CompareTrueSampleZQ
            figure
            
            subplot(2,1,1)
            imagesc(obj.A)
            title('Data')
            subplot(2,1,2)
            imagesc(obj.PostPredDistMat,[0 1])
            colorbar
            title('Posterior Predictive Distribution')
        end
        
        function plotChains(obj)
            %             subplot(6,4,[1:8])
            plot(obj.logPs(3,:))
            hold on
            
            if isempty(obj.logpIDX)
                obj = obj.computeZQMAP;
            end
            
            scatter(obj.logpIDX,obj.logpMAP,'filled','r')
            hold off
            xlabel('Iterations')
            ylabel('Log-likelihood')
            %             % plot hyperparameters
            %             subplot(6,4,9:16)
            %             hold on
            %             pms_data = cat(3,obj.pmsSamples{:});
            %
            %
            %             col = hsv(8);
            %             range = 1:numel(pms_data(1,1,:));
            %             for i = 1:size(obj.pms,1)
            %                 for j = 1:size(obj.pms,2)
            %                     plot(log(reshape(pms_data(i,j,range),1,...
            %                         numel(pms_data(i,j,range)))),'color'...
            %                         ,col(sub2ind([2,4],j,i),:),'linewidth',1)
            %                 end
            %             end
            %             hold off
            %             %% and logP(pms) individually at MAP
            %             col = hsv(8);
            %             sbplts = 17:24;
            %             for i = 1:4
            %                 for j = 1:2
            %                     mySuffStats = SuffStatsClass;
            %                     MAPpms = obj.pmsSamples{jMax};
            %                     logMid=log(MAPpms(i,j))/log(10);
            %                     test_values=logspace(logMid-0.1, logMid+0.1);
            %                     pmsAll = repmat(MAPpms,1,1,numel(test_values));
            %                     pmsAll(i,j,:) = test_values;
            %                     logPs = zeros(1,numel(test_values));
            %                     for k = 1:numel(test_values)
            %                         logPs(k)=LogJoint(true,obj.Atrue,obj.zSamples{MAPSampleZ},...
            %                             obj.qSamples{MAPSampleQ},pmsAll(:,:,k),mySuffStats);
            %                     end
            %                     subplot(6,4,sbplts((j-1)*4+i));
            %                     %yy = exp(logPs)./(trapz(exp(logPs)));
            %                     yy = logPs;
            %                     plot((test_values),yy,'linewidth',2,'color',col(sub2ind([2,4],j,i),:))
            %                 end
            %             end
        end
        
        function obj = computeAUC(obj)
            if sum(sum(obj.PostPredDistMat)) == 0
                disp('Compute Posterior Predictive Distribuiton first')
                disp('Use method ''PosteriorPredictive''')
            end
            md = obj.MissingData;
            if isempty(md)
                [~,~,~,obj.AUC] = perfcurve(reshape(obj.Atrue,1,numel(obj.Atrue)),...
                    reshape(obj.PostPredDistMat,1,numel(obj.PostPredDistMat)),1);
            else
                [~,~,~,obj.AUC] = perfcurve(reshape(obj.Atrue(md),1,numel(obj.Atrue(md))),...
                    reshape(obj.PostPredDistMat(md),1,numel(obj.PostPredDistMat(md))),1);
            end
        end
        
        function plotZQ(obj)
            subplot(3,2,1)
            imagesc(obj.zTrue)
            subplot(3,2,2)
            imagesc(obj.qTrue)
            
            obj = obj.updateZQsort;
            
            subplot(3,2,3)
            imagesc(obj.zTrueSorted)
            subplot(3,2,4)
            imagesc(obj.qTrueSorted)
            
            if isempty(obj.zMAP)
                obj = obj.computeZQMAP;
            end
            
            subplot(3,2,5)
            imagesc(obj.zMAPSorted)
            subplot(3,2,6)
            imagesc(obj.qMAPSorted)
        end
        
        
        function plotASorted(obj)
            
            obj = obj.updateZQsort;
            
            ActMAP = ~isempty(obj.zMAPSorted);
            ActKnown = ~isempty(obj.zTrue);
            
            
            nPlots = 1+ActMAP+ActKnown;
            pltid=1;
            
            
            if nPlots == 2;
            subplot(nPlots,1,pltid)
            imagesc(obj.Atrue)
            pltid = pltid+1;
            end
            
            if ActKnown
                subplot(nPlots,1,pltid)
                imagesc(obj.Atrue(obj.zTrueItemsPerm,obj.qTrueItemsPerm))
                pltid=pltid+1;
                title('A sorted according to Known Z and Q')
                set(gca,'XTickLabel',[])
                set(gca,'YTickLabel',[])
            end
            if ActMAP
                subplot(nPlots,1,pltid)
                obj = obj.computeLinkProbabilities;
                paMat = repmat(obj.linkProbs(1,:),size(obj.A,1),1);
                pbMat = repmat(obj.linkProbs(2,:),size(obj.A,1),1);
                ZQMat = (obj.zMAP*obj.qMAP'>0);
                linkProbMat = ZQMat.*paMat+(1-ZQMat).*pbMat;
                imagesc(linkProbMat(obj.zTrueItemsPerm,obj.qTrueItemsPerm))
                title('Link-Probabilities sorted according to Known Z and Q')
                set(gca,'XTickLabel',[])
                set(gca,'YTickLabel',[])
                pltid = pltid + 1;
                
                
                subplot(nPlots,1,pltid)
                imagesc(obj.Atrue(obj.zMAPItemsPerm,obj.qMAPItemsPerm))
                title('A sorted according to MAP Z and Q')
                set(gca,'XTickLabel',[])
                set(gca,'YTickLabel',[])
%                 set(gca,'YTick',1:size(obj.Atrue,1));
%                 set(gca,'XTick',1:size(obj.Atrue,2));
                
%                 if ~isempty(obj.qLabels)
%                     set(gca,'XTickLabel',obj.qLabels(obj.qMAPItemsPerm));
%                 else
%                     set(gca,'XTickLabel',obj.qMAPItemsPerm);
%                 end
%                 if ~isempty(obj.zLabels)
%                     set(gca,'YTickLabel',obj.zLabels(obj.zMAPItemsPerm));
%                 else
%                     set(gca,'YTickLabel',obj.zMAPItemsPerm);
%                 end
                
            end
        end
    end
    methods (Static)
        % Generate Data
        [A,Z,Q,pa,pb,Bds,Rds] = GenerateDataFromModel(obs,feas,concs,bs,rs,pas,pbs)
        
    end
    
    
end