classdef GibbsSamplerC
    properties
        %%  Input
        A % Data Matrix
        Atrue
        T=0; % Total # of samples
        Tstart=0; % Changes if error occurs to resume sampling
        pms % Hyperparameters (current)
        pmsTrue % if generated
        d % Number of communities
        dTrue
        k % k-flip parameter
        zTrue % Generated Z matrix (if available)
        qTrue % Generated Q matrix (if available)
        zLabels
        qLabels
        MissingData % Indices of missing data
        
        %% Settings
        Debug = false;
        ActiveGibbs = true;
        Constrained = true;
        activeHyper = true;
        hyperindex = [];
        verbose = true;
        
        %% Output
        zSamples % Samples generated by gibbs
        qSamples % Samples generated by gibbs
        pmsSamples % Samples generated by gibbs
        logPs % Log probability of samples
        SuffStatAll % SuffStats
        cpuTime
        wallTime
        PostPredDistMat % Posterior Predictive Distribution
        AUC
    end
    methods
        % CONSTRUCTOR ************
        function obj = GibbsSamplerC(A,d,k,pms,Z,Q)
            if nargin == 1; % default values
                
                % input arg A is seed for RNG
                
                obs = 10; % No. of observations
                feas = obs; % No. of features
                obj.dTrue = 3; % No. of concepts
                obj.k = 2; % No. used in k-flip
                
                bs = [10 10];
                rs = [10 10];
                
                pas = [1 0.1]; % pa_plus, pa_minus
                pbs = [0.1 1]; % pb_plus, pb_minus
                rng(A)
                [obj.A,obj.zTrue,obj.qTrue] = GenerateDataFromModel(obs,feas,obj.dTrue,bs,rs,pas,pbs);
                obj.pmsTrue = [bs; rs; pas; pbs;];%Parameters
                obj.d = 3;%12;
                obj.pms = [1 1; 1 1; 1 1; 1 1];
            else
                obj.A = A;
                obj.d = d;
                obj.k = k;
                if nargin < 4
                    % default pms if no other given
                    obj.pms = [1 1; 1 1; 1 1; 1 1];
                else
                    obj.pms = pms;
                    if nargin > 5
                        % if know Z and Q exists (synthetic data)
                        obj.zTrue = Z;
                        obj.qTrue = Q;
                    end
                end
            end
            obj.PostPredDistMat = zeros(size(obj.A));
            obj.Atrue = obj.A;
            %rng('shuffle')
        end
        
        % CLASS FUNCTIONS (EXTERNAL/CLASSFOLDER) ************
        % Sampler (See class folder for functions)
        obj = Sampler(obj,nSamples)
        
        % LogJoint her
        [max_prob, sample_max_Z, sample_max_Q,i,idx2] = findMAP(obj)
        CompareTrueSampleZQ(obj,MAP,mymode)
        
        obj = PosteriorPredictive(obj)
        
        
        % COMPUTATIONS ************
        function obj = LeaveOneOut(obj,nSamples)
            % Default values
            if nargin < 2
                nSamples = 200;
            end
            
            obj.PostPredDistMat = zeros(size(obj.PostPredDistMat));
            
            %if obj.verbose
            display('Computing Leave-One-Out Posterior Predictive Distribution');
            %end
            for i = 1:size(obj.A,1);
                for j = 1:size(obj.A,2);
                    %if obj.verbose
                    display([i j]);
                    %end
                    tempobj=obj.createMissingdata([i j]);
                    tempobj=tempobj.Sampler(nSamples);
                    tempobj=tempobj.PosteriorPredictive;
                    obj.PostPredDistMat = obj.PostPredDistMat+tempobj.PostPredDistMat;
                end
            end
        end
        
        
        % UPDATES ************
        % Extending data structures to accomendate new samples
        function obj = updateT(obj,nSamples)
            obj.Tstart = obj.T+1;
            obj.T = obj.T+nSamples;
            %             if oldT<newT
            % Setting index for first sample
            %                 obj.T = newT;
            obj.logPs = [obj.logPs nan(3,nSamples)];
            obj.pmsSamples{obj.T} = [];
            obj.SuffStatAll{obj.T} = [];
            obj.zSamples{obj.T} = [];
            obj.qSamples{obj.T} = [];
            obj.cpuTime(obj.T) = 0;
            obj.wallTime(obj.T) = 0;
        end
        % Create missing data
        function obj = createMissingdata(obj,param)
            if nargin == 1;
                Percent = 0.1;
                obj.A(randperm(numel(obj.A),round(numel(obj.A)*Percent))) = NaN;
                obj.MissingData = find(isnan(obj.A));
            elseif numel(param)==1
                obj.A(randperm(numel(obj.A),round(numel(obj.A)*param))) = NaN;
                obj.MissingData = find(isnan(obj.A));
            elseif numel(param)==2
                obj.A(param(1),param(2)) = nan;
                obj.MissingData = sub2ind(size(obj.A),param(1),param(2));
            end
        end
        % RESULTS ************
        function plotMatrices(obj)
            %figure
            %obj.CompareTrueSampleZQ
            figure
            
            subplot(2,1,1)
            imagesc(obj.A)
            title('Data')
            subplot(2,1,2)
            imagesc(obj.PostPredDistMat,[0 1])
            colorbar
            title('Posterior Predictive Distribution')
        end
        
        function plotChains(obj)
            subplot(6,4,[1:8])
            plot(obj.logPs(3,:))
            [MAPP,MAPSampleZ,MAPSampleQ,~,jMax] = obj.findMAP;
            hold on
            scatter(jMax,MAPP,'filled','r')
            hold off
            % plot hyperparameters
            subplot(6,4,9:16)
            hold on
            pms_data = cat(3,obj.pmsSamples{:});
            
            
            col = hsv(8);
            range = 1:numel(pms_data(1,1,:));
            for i = 1:size(obj.pms,1)
                for j = 1:size(obj.pms,2)
                    plot(log(reshape(pms_data(i,j,range),1,...
                        numel(pms_data(i,j,range)))),'color'...
                        ,col(sub2ind([2,4],j,i),:),'linewidth',1)
                end
            end
            hold off
            %% and logP(pms) individually at MAP
            col = hsv(8);
            sbplts = 17:24;
            for i = 1:4
                for j = 1:2
                    mySuffStats = SuffStatsClass;
                    MAPpms = obj.pmsSamples{jMax};
                    logMid=log(MAPpms(i,j))/log(10);
                    test_values=logspace(logMid-0.1, logMid+0.1);
                    pmsAll = repmat(MAPpms,1,1,numel(test_values));
                    pmsAll(i,j,:) = test_values;
                    logPs = zeros(1,numel(test_values));
                    for k = 1:numel(test_values)
                        logPs(k)=LogJoint(true,obj.Atrue,obj.zSamples{MAPSampleZ},...
                            obj.qSamples{MAPSampleQ},pmsAll(:,:,k),mySuffStats);
                    end
                    subplot(6,4,sbplts((j-1)*4+i));
                    %yy = exp(logPs)./(trapz(exp(logPs)));
                    yy = logPs;
                    plot((test_values),yy,'linewidth',2,'color',col(sub2ind([2,4],j,i),:))
                end
            end
        end
        
        function obj = computeAUC(obj)
            if sum(sum(obj.PostPredDistMat)) == 0
                disp('Compute Posterior Predictive Distribuiton first')
                disp('Use method ''PosteriorPredictive''')
            end
            [~,~,~,obj.AUC] = perfcurve(reshape(obj.Atrue,1,numel(obj.Atrue)),...
                reshape(obj.PostPredDistMat,1,numel(obj.PostPredDistMat)),1);
        end
        
        function plotASorted(obj)
            [~,MAPSampleZ,MAPSampleQ,~,~] = obj.findMAP;
            zMAP = obj.zSamples{MAPSampleZ};
            qMAP = obj.qSamples{MAPSampleQ};
            [~, idx_obj_Z, ~] = sort_matrix(zMAP,1);
            [~, idx_obj_Q, ~] = sort_matrix(qMAP,1);
            
            imagesc(obj.Atrue(idx_obj_Z,idx_obj_Q))
            
            zLabels = obj.zLabels;
            qLabels = obj.qLabels;
            
            set(gca,'YTick',1:size(obj.Atrue,1));
            set(gca,'XTick',1:size(obj.Atrue,2));
            
            if ~isempty(qLabels)
                set(gca,'XTickLabel',qLabels(idx_obj_Q));
            else
                set(gca,'XTickLabel',idx_obj_Q);
            end
            if ~isempty(zLabels)
                set(gca,'YTickLabel',zLabels(idx_obj_Z));
            else
                set(gca,'YTickLabel',idx_obj_Z);
            end
            title('A sorted according to MAP Z and Q')
        end
        
        
    end
    
    
end